# SPDX-License-Identifier: LGPL-2.1-or-later

"""
OpenRadioss Constraint Writer

This module provides functions to write constraint data in OpenRadioss format.
"""

import FreeCAD as App
import Part


def get_before_write_constraint():
    """Get header text to write before constraints"""
    return (
        "$$\n"
        "$$ OpenRadioss Constraint Definitions\n"
        "$$ Generated by FreeCAD FEM Nodeset Extractor\n"
        f"$$ Date: {App.Base.ParamGet('User parameter:BaseApp/Preferences/General').GetString('DocumentSaveBackupDateFormat', '%Y-%m-%d %H:%M:%S')}\n"
        "$$\n\n"
    )


def get_after_write_constraint():
    """Get footer text to write after constraints"""
    return ("\n$$ End of OpenRadioss constraint definitions\n")


def get_closest_node(mesh, point, tolerance=1e-6):
    """Find the closest node to a given point within a tolerance."""
    min_dist = float('inf')
    closest_node = None
    
    for node_id, node in mesh.Nodes.items():
        dist = (node - point).Length
        if dist < min_dist and dist < tolerance:
            min_dist = dist
            closest_node = node_id
    
    return closest_node


def get_nodes_for_edge(mesh, edge, tolerance=1e-6):
    """Get nodes for an edge reference."""
    nodes = set()
    edge_curve = edge.Curve
    
    for node_id, node in mesh.Nodes.items():
        # Project point to edge curve
        try:
            param = edge_curve.parameter(Part.Vertex(Part.Point(node)).Point)
            
            # Get point on curve at parameter
            curve_point = edge_curve.value(param)
            dist = (node - curve_point).Length
            
            # Check if point is on edge within tolerance
            if dist < tolerance and edge.distToShape(Part.Vertex(Part.Point(node)))[0] < tolerance:
                nodes.add(node_id)
        except:
            continue
    
    return nodes


def get_nodes_for_face(mesh, face, tolerance=1e-6):
    """Get nodes for a face reference."""
    nodes = set()
    
    for node_id, node in mesh.Nodes.items():
        # Create a vertex at the node position
        vertex = Part.Vertex(Part.Point(node))
        
        # Check if the node is on the face within tolerance
        dist, _, _ = face.distToShape(vertex)
        if dist < tolerance:
            nodes.add(node_id)
    
    return nodes


def write_meshdata_constraint(f, femobj, constraint_obj, radioss_writer):
    """Write mesh data for a constraint in OpenRadioss format"""
    if not hasattr(constraint_obj, 'References') or not constraint_obj.References:
        return
    
    # Get the mesh from the writer context
    mesh = radioss_writer.mesh_object.FemMesh
    if not mesh:
        return
    
    # Write nodeset for the constraint
    f.write(f"$$ Nodeset for constraint: {constraint_obj.Name}\n")
    f.write("/NODE/\n")
    
    # Get nodes from the constraint references
    nodes = set()
    
    for ref in constraint_obj.References:
        if not ref[1]:  # No subshapes specified
            continue
            
        shape = ref[0].Shape
        if not shape:
            continue
            
        for subshape_name in ref[1]:
            # Get the subshape (Face, Edge, or Vertex)
            subshape = getattr(shape, subshape_name, None)
            if not subshape:
                continue
                
            # Get nodes based on subshape type
            if hasattr(subshape, 'Vertexes') and len(subshape.Vertexes) == 1:  # Vertex
                vertex = subshape.Vertexes[0]
                node_id = get_closest_node(mesh, vertex.Point)
                if node_id is not None:
                    nodes.add(node_id)
                    
            elif hasattr(subshape, 'Vertexes') and len(subshape.Vertexes) == 2:  # Edge
                edge_nodes = get_nodes_for_edge(mesh, subshape)
                nodes.update(edge_nodes)
                
            elif hasattr(subshape, 'Faces'):  # Face
                face_nodes = get_nodes_for_face(mesh, subshape)
                nodes.update(face_nodes)
    
    # Write nodes in Radioss format
    for node_id in sorted(nodes):
        node = mesh.Nodes[node_id]
        f.write(f"{node_id:10d}{node.x:16.9E}{node.y:16.9E}{node.z:16.9E}\n")
    
    f.write("\n")


def write_constraint(f, femobj, constraint_obj, radioss_writer):
    """Write constraint data in OpenRadioss format"""
    if not hasattr(constraint_obj, 'Proxy') or not hasattr(constraint_obj.Proxy, 'Type'):
        f.write(f"$$ Error: Invalid constraint object {constraint_obj.Name}\n\n")
        return
    
    constraint_type = constraint_obj.Proxy.Type.split('::')[-1].lower()
    
    # Write constraint header
    f.write(f"$$ {'=' * 50}\n")
    f.write(f"$$ Constraint: {constraint_obj.Name} (Type: {constraint_type})\n")
    f.write(f"$$ {'-' * 50}\n")
    
    try:
        # Handle different constraint types
        if 'fixed' in constraint_type or 'displacement' in constraint_type:
            write_fixed_constraint(f, femobj, constraint_obj, radioss_writer)
        elif 'force' in constraint_type or 'pressure' in constraint_type:
            write_force_constraint(f, femobj, constraint_obj, radioss_writer)
        else:
            f.write(f"$$ Unsupported constraint type: {constraint_type}\n")
            f.write("$$ No OpenRadioss equivalent found.\n")
    except Exception as e:
        import traceback
        error_msg = f"Error processing constraint {constraint_obj.Name}: {str(e)}\n"
        error_msg += f"Stack trace:\n{traceback.format_exc()}\n"
        f.write(f"$$ {error_msg}")
        App.Console.PrintError(error_msg)
    
    f.write(f"$$ {'=' * 50}\n\n")


def write_fixed_constraint(f, femobj, constraint_obj, radioss_writer):
    """Write fixed constraint in OpenRadioss format"""
    # Get the mesh to determine the node set name
    mesh = radioss_writer.mesh_object.FemMesh if hasattr(radioss_writer, 'mesh_object') else None
    
    # Write BC_DOF card for fixed constraints
    f.write("/BC_DOF/\n")
    f.write(f"{constraint_obj.Name:10d}        0\n")
    
    # Get DOF constraints
    # Default to all DOFs fixed if no specific constraints are set
    dof_constraints = [1, 1, 1, 1, 1, 1]  # TX, TY, TZ, RX, RY, RZ
    
    # Adjust based on constraint properties if available
    if hasattr(constraint_obj, 'xFix') and not constraint_obj.xFix:
        dof_constraints[0] = 0
    if hasattr(constraint_obj, 'yFix') and not constraint_obj.yFix:
        dof_constraints[1] = 0
    if hasattr(constraint_obj, 'zFix') and not constraint_obj.zFix:
        dof_constraints[2] = 0
    
    # Write DOF constraints
    f.write(" ".join(map(str, dof_constraints)) + "\n")
    
    # Write node set reference if mesh is available
    if mesh and hasattr(constraint_obj, 'References') and constraint_obj.References:
        f.write(f"$$ Referenced by: {constraint_obj.Name} (Fixed Constraint)\n")
        f.write(f"$$ Nodes: {len(constraint_obj.References[0][1]) if constraint_obj.References[0][1] else 'all'}\n\n")


def write_force_constraint(f, femobj, constraint_obj, radioss_writer):
    """Write force constraint in OpenRadioss format"""
    # Get force values with defaults
    force = getattr(constraint_obj, 'Force', App.Vector(0, 0, 0))
    fx = force.x if hasattr(force, 'x') else 0.0
    fy = force.y if hasattr(force, 'y') else 0.0
    fz = force.z if hasattr(force, 'z') else 0.0
    
    # Get direction if available (for directional forces)
    direction = getattr(constraint_obj, 'Direction', None)
    if direction and hasattr(direction, 'x') and hasattr(direction, 'y') and hasattr(direction, 'z'):
        # Normalize direction vector
        length = (direction.x**2 + direction.y**2 + direction.z**2)**0.5
        if length > 1e-10:
            dir_x = direction.x / length
            dir_y = direction.y / length
            dir_z = direction.z / length
            
            # Apply direction to force vector
            force_magnitude = (fx**2 + fy**2 + fz**2)**0.5
            if force_magnitude > 1e-10:
                fx = force_magnitude * dir_x
                fy = force_magnitude * dir_y
                fz = force_magnitude * dir_z
    
    # Write CLOAD card for force constraints
    f.write("/CLOAD/\n")
    f.write(f"{constraint_obj.Name:10d}        1\n")  # 1 = force type
    
    # Write force values
    f.write(f"{fx:16.9E}{fy:16.9E}{fz:16.9E}\n")
    
    # Write node set reference if available
    if hasattr(constraint_obj, 'References') and constraint_obj.References:
        f.write(f"$$ Referenced by: {constraint_obj.Name} (Force Constraint)\n")
        f.write(f"$$ Force: {fx:.3f}, {fy:.3f}, {fz:.3f}\n\n")
